---
title: 'React Children & TypeScript - wszystko co powinieneś wiedzieć'
category: 'React'
publishedAt: '24-08-2021'
isPublished: true
popular: false
image: '/images/react-query-wprowadzenie/react-query.png'
excerpt: 'Koncepcja dzieci w Reakcie pojawia się nam już w bardzo wczesnych etapach nauki. Ich sposób działania po chwili okazuje się bardzo prosty, ale w praktyce childreny oferują znacznie więcej, są trochę tricki i potrafią zaskoczyć 🤔 Jak więc sobie z nimi radzić i na uważać podczas ich wykorzystania?'
---

Koncepcja dzieci w Reakcie pojawia się nam już w bardzo wczesnych etapach nauki. Ich sposób działania po chwili okazuje się bardzo prosty, ale w praktyce `children` oferują znacznie więcej, są trochę _tricki_ i potrafią zaskoczyć 🤔 Jak więc sobie z nimi radzić i na uważać podczas ich wykorzystania? Jedziemy z tematem!

## Podstawy

Jeśli do tej pory nie słyszałeś o dzieciach w React, to polecam na starcie odzwiedzić [oficjalną dokumentację](https://pl.reactjs.org/docs/composition-vs-inheritance.html). A my jedziemy z powtórką! Dzieci są spejcalnymi propsami, które pomagają nam w komponowaniu komponentów. Spójrz na przykład:

```tsx
type ListProps = {
  children: '?';
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple 🍏</li>
    <li>Banana 🍌</li>
    <li>Strawberry 🍓</li>
  </List>
);
```

Tworzymy dwa komponenty, pierwszy `<List>`, który będzie przyjmował dzieci, oraz komponent `<App>`, który będzie wywolywał ten pierwszy. Podczas wywołania komponentu `<List>` do jego **środka** przekazujemy np. elementy HTML, ot cała filozofia...Tylko, że nie do końca!

## Typy

I tutaj zaczyna się prawdziwa zabawa. W teorii `chilren` mogą być wszystkim, jednak często chcemy, aby były czymś bardziej konkretnym, spójrzmy na dostępne opcje:

### ReactNode

Typ `React.ReactNode` to najpopularniejsza z opcji. Korzysta z niej np. nie polecany przeze mnie typ `React.FC`. Wracając, `React.ReactNode` jest bardzo giętkim typem i przepuszcza przez nasze dzieci dosłownie wszystko: portal, tekst, liczy, boolean, elementy, komponenty...

```tsx
type ListProps = {
  children: React.ReactNode;
};

const List = ({ children }: ListProps) => <div>{children}</div>;

const App = () => (
  <List>
    <li>Apple 🍏</li>
    Banana 🍌 ['Strawberry 🍓'] false
  </List>
);
```

### ReactElement

Dzięki `React.ReactElement` nasze _childreny_ będą mogłby być tylko komponentem/elementem HTML:

```tsx
type ListProps = {
  children: Array<React.ReactElement>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const ListItem = () => <span>Apple 🍏</span>;

const App = () => (
  <List>
    <ListItem />
    <p>Banana 🍌</p>
    <h2>Strawberry 🍓</h2>
  </List>
);
```

### ReactText

Typ `React.ReactText` akceptuje tylko ciąg znaków/liczb. Zdecydowanie lepsza opcja jeśli chcemy wprowadzić takie ogarniczenia:

```tsx
type ListProps = {
  children: React.ReactText;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => <List>Apple 🍏 Banana 🍌 Strawberry 🍓</List>;
```

## ReactChild

Ten typ jest połączeniem (a taka naprawdę unią) typów `ReactElement` i `ReactText`:

```tsx
type ListProps = {
  children: React.ReactChild;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    Apple 🍏 <li>Banana 🍌</li> Strawberry 🍓
  </List>
);
```

## Zawężenie typu

Załóżmy, że w naszym kodzie chcemy zadeklarować tak jak wyżej komponent `<List>`, który będzie nieoznaczoną listą. Z racji tego, że dziećmi `<ul>` mogą być **tylko** `<li>`, chcieli byśmy nałożyć ograniczenie dla `children` na ten konkretny tag, czy to możliwe?

Na pierwszy strzał niech poleci `React.ReactElement`, jest on typem generycznym do którego możemy podać konkretny element, czy to wystarczy?

```tsx
type ListProps = {
  children: React.ReactElement<'li'>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple 🍏</li>
    Banana 🍌 Strawberry 🍓
  </List>
);
```

Okazuję się, że nie ❌ Spróbujmy jeszcze inaczej:

```tsx
const ListItem = ({ name }: { name: string }) => <li>{name}</li>;

type ListProps = {
  children: React.ReactElement<'li'>; // ❌
  children: JSX.InstrictElements['li']; // ❌
  children: typeof ListItem; // ❌
  ... //  ❌
};
```

Te i inne opcje po prostu nie zadziałają tak jakbyśmy tego oczekiwali... Dzieje się to z tego względu, że komponenty/elementy zamieniane są w locie na typ `JSX.Element`, a szkoda.

<Newsletter />

## Nie jakość, a ilość

Co pozostaje nam, biednym Reaktowcom, jeśli nie możemy wskazać dokładnego typu? Wskazanie **dokładnej ilości!** No może nie w 100% dokładniej, ale zawsze coś. W naszym typie możemy wskazać czy `children` będą np. pojedynczym elementem, tablicą elementów lub tuplem (tablica o określonej długości i określonych typach):

```tsx
import { ReactElement } from 'react';

type ListProps = {
  children: ReactElement;
  children: Array<ReactElement>;
  children: [ReactElement, ReactElement, ReactElement];
  children: [ReactElement, ReactText, ReactFragment];
};
```

## Metody iteracyjne

React oprócz samego mechanizmu komponentów rodziców i dzieci udostępnia nam również szereg metod dla API `React.Children`. Nie będę Ci tutaj przytaczał wszystkich, są one bardzo dobrze opisane w [dokumentacji](https://pl.reactjs.org/docs/react-api.html#reactchildren). Chciałbym jednak wrócić do naszego problemu, wiemy już, że nie możemy w pełni bezpiecznie otypować dzieci, jak więc obejść ten problem?

1. Deklarujemy typ dla `children`, ustawiamy go jako tablię `React.ReactElement`
2. Korzystamy z metody `toArray` obiektu `Children`, która zwraca dzieci jako płaską strukturę
3. Sprawdzamy, czy aby na pewno nasz `child` jest elementem Reaktowym. Dlaczego tak, skoro w propsach mamy już pewność? W wyniku metody `toArray` każde z naszych dzieci będzie miało typ `ReactChild | ReactFragment | ReactPortal`, my chcemy mieć pewność, że jest to `ReactElement`. Moglibyśmy do tego celu stworzyć dedykowanego _type guarda_, ale React nas wyręcza i udostępnia funkcję `isValidElement`
4. Spradzamy, czy typ dziecka jest równy typowi jaki posiada `<li>`
5. Jeśli tak, klonujemy i zwracamy `child`
6. Jeśli nie, opakowujemy `child` w tag `<li>`
7. Jeśli nic z tego nie jest prawdą, po prostu zwracamy `child` (dla pewności)
8. Całość opakowujemy w zmienną i przekazujemy do `<ul>`

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';

type ListProps = {
  // #1
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  // #2
  const newChildren = Children.toArray(children).map((child) => {
    // #3
    if (isValidElement(child)) {
      // #4
      if (child.type === 'li') {
        // #5
        return cloneElement(child, { key: child.key });
      }
      // #6
      return <li key={child.key}>{child}</li>;
    }
    // #7
    return child;
  });
  // #8
  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple 🍏</li>
    <a href="banana.html">Banana 🍌</a>
    <p>Strawberry 🍓</p>
  </List>
);
```

### Problemy z React.Fragment

Wszystko byłoby pięknie, gdyby nie `React.Fragment`. Domyślnie metoda `React.Children.toArray()` spłaszcza nam strukturę `children`, ale... No właśnie, pozostawia fragmenty. Problem pojawia się gdy do naszej listy podamy dzieci w takiej formie:

```tsx
<List>
  <li>Apple 🍏</li>
  <>
    <a href="banana.html">Banana 🍌</a>
    <p>Strawberry 🍓</p>
  </>
</List>
```

Zamiast trzech `<li>` zostaną wyrenderowane dwa. Jak temu zaradzić? Powstała [biblioteka](https://github.com/grrowl/react-keyed-flatten-children) specjalnie pod ten problem, która udostępnia funkcje `flattenChildren`. Zobaczmy na cały, poprawiony przykład:

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';
import flattenChildren from 'react-keyed-flatten-children';

type ListProps = {
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren.map((child) => {
    if (isValidElement(child)) {
      if (child.type === 'li') {
        return cloneElement(child, { key: child.key });
      }

      return <li key={child.key}>{child}</li>;
    }

    return child;
  });

  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple 🍏</li>
    <>
      <a href="banana.html">Banana 🍌</a>
      <p>Strawberry 🍓</p>
    </>
    <span>Blueberry 🫐</span>
  </List>
);
```

## Podsumowanie

To by było na tyle jeśli chodzi o `children` w React & TypeScript. Polecam Ci szczególnie zapoznać się z innymi metodami dla `React.Children`, chociaż nie stosuje się ich na codzień, to jak widać, potrafią się przydać :)

Jeśli ten artykuł okazał się dla Ciebie przydatny, podziel się nim z innymi!

Do słyszenia!

### Czytaj więcej

- [React Children API](https://pl.reactjs.org/docs/react-api.html#reactchildren)
- [React TypeScript CheatSheet](https://github.com/typescript-cheatsheets/react)
